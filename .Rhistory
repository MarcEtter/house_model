poststrat_full = poststrat_df)
########################################################
#(2) District vote share estimates
vote_choice_fit <- readRDS(vote_choice_model_file)
predictors <- str_extract_all(as.character(likely_voter_fit$formula), '(?<= )[a-zA-Z_]*(?=[)]| )')[[1]]
#In order to speed up computation of posterior matrix, I compressed the post-stratification table
#to contain unique combinations of predictor values, to be merged with full table later
POSTSTRAT_UNIQUE <- poststrat_df |> select(all_of(predictors)) |> unique()
vote_choice_posterior <- mrp_posterior(vote_choice_fit, POSTSTRAT_UNIQUE)[1:N_DRAWS, , ]
mrp_list <- polytomous_mrp(posterior = vote_choice_posterior,
poststrat_full = poststrat_df)
vote_choice_array <- mrp_list$mrp_array
vote_margin <- mrp_list$margin_table
vote_margin <- override_no_contest(vote_margin)
#Re-weight MRP estimates such that sum of vote shares across districts equal
#national vote share projected by Pew Research
mrp_list <- reweight_mrp(vote_choice_array, vote_margin)
vote_array_weighted <- mrp_list$mrp_array
vote_margin_weighted <- mrp_list$margin_table
vote_margin_weighted <- override_no_contest(vote_margin_weighted)
write.csv(vote_margin, 'cleaned_data/mrp_margin.csv')
write.csv(vote_margin_weighted, 'cleaned_data/mrp_margin_weight.csv')
########################################################
#(3) District vote share estimates (weighted by turnout)
#element-wise posterior matrix multiplication of 2D matrix by each level of 3D matrix
adj_vote_choice_posterior <- sweep(vote_choice_posterior, c(1, 2), likely_voter_posterior, `*`)
mrp_list <- polytomous_mrp(posterior = adj_vote_choice_posterior,
poststrat_full = poststrat_df)
adj_vote_choice_array <- mrp_list2$mrp_array
library(tidyverse)
library(brms)
library(stringr)
#library(nnet)#for multinomial regression
################################################################################
#Compute Posterior Distribution of District-Level Vote Shares
#mem.maxVSize(1e9) #Avoid memory error
FILTER_COL <-'state_district'
N_DRAWS <- 1000#Default number of posterior draws in epred_mat is 4000 (set to 100 to save memory)
poststrat_file <- 'cleaned_data/poststrat_district_2016.csv'
vote_choice_model_file <- 'models/vote_brms3.rds'
likely_voter_model_file <- 'models/likely_voter_brms4.rds'
poststrat_df <- read.csv(poststrat_file) |> select(-matches('X', ignore.case = F))
#To override predictions in uncontested races
BASELINE_NO_CONTEST <- read.csv('cleaned_data/baseline_mod_predictions.csv')
################################################################################
# Get matrix of posterior predictions (rows = posterior samples, cols = areas)
mrp_posterior <- function(fit, poststrat, n_posterior_draws = 4000){
# Get posterior estimates for each subgroup in poststrat table
#if posterior_epred gives error 'function 'cholmod_factor_ldetA' not provided by', reinstall lme4: install.packages("lme4", type = "source")
epred_mat <- posterior_epred(fit, newdata = poststrat, draws = n_posterior_draws)#default number of draws?
return (epred_mat)
}
# Write predictions for each poststratification cell to a file in a directory
# corresponding to the model
mrp_diagnostic <- function(poststrat, poststrat_file, model_file, index = FALSE, epred_mat){
mrp_estimates_vector <- epred_mat %*% poststrat$n / sum(poststrat$n)
mrp_estimate <- c(mean(mrp_estimates_vector), sd(mrp_estimates_vector))
#browser()
debug_info <- cbind(poststrat, colMeans(epred_mat), t(epred_mat))
debug_dir <- paste0('debug/', gsub('.rds', '', model_file), index)
if (index){ debug_dir <- paste0(debug_dir, index) }
version <- strsplit(poststrat_file, '/')
version <- gsub('.csv', '', version[[1]][length(version[[1]])])
debug_file <- paste0(debug_dir, '/', version, '_epred.csv')
if (!dir.exists(debug_dir)) {
dir.create(debug_dir, recursive = TRUE)
}
write.csv(debug_info, debug_file)
return (debug_info)
}
#Function to create a data frame with one entry per area in post-stratification table
get_area_df <- function(poststrat){
area_df <- data.frame(
area = poststrat |> dplyr::rename(area = !!rlang::sym(FILTER_COL)) |>
select(area) |> unique(),
mrp_estimate = NA,
mrp_estimate_se = NA)
area_df <- area_df |> mutate()
return (area_df)
}
mrp_estimate <- function(poststrat, epred_mat){
area_df <- get_area_df(poststrat)
#create matrix to store posterior distribution for each area
area_posterior_mat <- matrix(nrow = nrow(area_df), ncol = nrow(epred_mat))
# Loop to populate the dataframe
for(i in 1:nrow(area_df)) {
# Currently, the matrix epred_mat and the poststratification table contain 150,000
# rows. We need to filter the ones that correspond to county in row i. We do so
# by defining the following condition:
filtering_condition <- which(poststrat[ ,FILTER_COL] == area_df$area[i])
state_epred_mat <- epred_mat[ ,filtering_condition]
k_filtered <- poststrat[filtering_condition, ]$n
tryCatch({
mrp_estimates_vector_sub <- state_epred_mat %*% k_filtered / sum(k_filtered)
area_posterior_mat[i, ] <- mrp_estimates_vector_sub
}, error = function(msg){
browser()
return(NA)
})
# MRP estimate for state in row i
area_df$mrp_estimate[i] <- mean(mrp_estimates_vector_sub)
area_df$mrp_estimate_se[i] <- sd(mrp_estimates_vector_sub)
}
#browser()
#Return all posterior estimates
area_df <- cbind(area_df, area_posterior_mat)
return(area_df)
}
###################################
#(1) Compute district turnout probabilities (binomial/continuous response)
bin_cont_mrp <- function(posterior, poststrat_full){
cat(paste0('Estimating MRP for binomial/continuous response...\n'))
#Undo compression of post-stratification table
posterior_expand <- left_join(poststrat_full,
cbind(POSTSTRAT_UNIQUE, t(posterior)),
by = predictors)
posterior_expand <- posterior_expand |>
select(matches('[0-9]+')) |>
as.matrix() |>
t()
# mrp_diagnostic(poststrat_full = poststrat_full,
#                poststrat_file = poststrat_file,
#                model_file = model_file,
#                epred_mat = posterior_expand)
mrp <- mrp_estimate(poststrat = poststrat_full, epred_mat = posterior_expand)
return(mrp)
}
###################################
#For polytomous response (voter choice and turnout-adjusted voter choice)
polytomous_mrp <- function(posterior, poststrat_full){
if (!(length(dim(posterior)) > 2)){
stop('Error: 2D posterior matrix does not appear to be polytomous.')
}
#3-D array to hold MRP posterior distribution by district by response category
mrp_array <- array(NA, dim = c(get_area_df(poststrat_full) |> nrow(),
N_DRAWS, dim(posterior)[3]))
for (i in 1:dim(posterior)[3]){
cat(paste0('Estimating MRP for polytomous response level ', i, '...\n'))
#Undo compression of post-stratification table
posterior_expand <- left_join(poststrat_full,
cbind(POSTSTRAT_UNIQUE, t(posterior[,,i])),
by = predictors)
posterior_expand <- posterior_expand |>
select(matches('[0-9]+')) |>
as.matrix() |>
t()
# mrp_diagnostic(poststrat_full = poststrat_full,
#                poststrat_file = poststrat_file,
#                index = i,
#                model_file = model_file,
#                epred_mat = posterior_expand)
mrp <- mrp_estimate(poststrat = poststrat_full, epred_mat = posterior_expand)
mrp_array[,,i] <- mrp |> select(matches('[0-9]+')) |> as.matrix()
}
#Get sum of each district/area posterior sample over 3 choices
#Normalize probability of each choice so that they sum to 1
totals <- mrp_array |> aperm() |> colSums()
mrp_array <- sweep(mrp_array, c(1, 2), t(totals), `/`)
r_d_margin <- mrp_array[,,2] - mrp_array[,,1]
margin_table <- data.frame(area = mrp$area)
margin_table <- cbind(margin_table, r_d_margin)
margin_table <- append_posterior_stats(margin_table)
return(list('mrp_array' = mrp_array, 'margin_table' = margin_table))
}
#Override model predictions when district is uncontested
override_no_contest <- function(df){
df <- df |>
mutate(state = substring(area, 1, 2),
district = substring(area, 4),
year = 2018,
district = as.integer(district)) |>
select(area, state, district, year, all_of(names(df))) |>
left_join(BASELINE_NO_CONTEST |>
select(unopposed_d_, unopposed_r_, state, district, year),
by = c('state', 'district', 'year')) |>
mutate(across(matches('[0-9]+'), ~ case_when(
unopposed_d_ == 1 ~ -1,
unopposed_r_ == 1 ~  1,
TRUE              ~ .
)))
df <- df |>
mutate(mean = df |> select(matches('[0-9]+')) |> rowMeans(),
r_d_victory_margin_mrp = mean)
return (df)
}
#Take dataframe of posterior draws for each district and add mean and sd of draws as column
append_posterior_stats <- function(df){
df <- df |>
mutate(mean = rowMeans(df |> select(-area)),
sd = apply(df |> select(-area), MARGIN = 1, sd)) |>
select(area, mean, sd, all_of(colnames(df)))
return (df)
}
#Re-weight MRP estimates such that sum of vote shares across districts equal
#national vote share projected by Pew Research
reweight_mrp <- function(mrp_array, margin_table){
pew <- read.csv('cleaned_data/pew_cleaned.csv') |>
select(-matches('X', ignore.case = F))
house_pv_target <- pew |> group_by(vote_choice) |>
reframe(voteshr = sum(weight_w), weight_w = weight_w) |>
mutate(voteshr = voteshr/sum(weight_w)) |>
group_by(vote_choice) |>
reframe(voteshr = voteshr) |>
unique()
mrp_dem_pv <- mrp_array[,,1] |> rowMeans() |> mean()
mrp_gop_pv <- mrp_array[,,2] |> rowMeans() |> mean()
mrp_unsure_pv <- mrp_array[,,3] |> rowMeans() |> mean()
house_pv_target <- house_pv_target |> mutate(
voteshr_mrp = c(mrp_dem_pv, mrp_gop_pv, mrp_unsure_pv),
weight = voteshr / voteshr_mrp
)
mrp_array[,,1] <- mrp_array[,,1] * as.double(house_pv_target[1, 'weight'])
mrp_array[,,2] <- mrp_array[,,2] * as.double(house_pv_target[2, 'weight'])
mrp_array[,,3] <- mrp_array[,,3] * as.double(house_pv_target[3, 'weight'])
r_d_margin <- mrp_array[,,2] - mrp_array[,,1]
margin_table <- margin_table |> select(area)
margin_table <- cbind(margin_table, r_d_margin)
margin_table <- append_posterior_stats(margin_table)
return(list('mrp_array' = mrp_array, 'margin_table' = margin_table))
}
##################################
#Compute (1) district turnout probabilities, (2) district vote share estimates,
#(3) district vote share estimates (weighted by cell-level turnout)
########################################################
#(1) Compute district turnout probabilities
likely_voter_fit <- readRDS(likely_voter_model_file)
predictors <- str_extract_all(as.character(likely_voter_fit$formula), '(?<= )[a-zA-Z_]*(?=[)]| )')[[1]]
#In order to speed up computation of posterior matrix, I compressed the post-stratification table
#to contain unique combinations of predictor values, to be merged with full table later
POSTSTRAT_UNIQUE <- poststrat_df |> select(all_of(predictors)) |> unique()
likely_voter_posterior <- mrp_posterior(likely_voter_fit, POSTSTRAT_UNIQUE)[1:N_DRAWS, ]
likely_voter_mrp <- bin_cont_mrp(posterior = likely_voter_posterior,
poststrat_full = poststrat_df)
########################################################
#(2) District vote share estimates
vote_choice_fit <- readRDS(vote_choice_model_file)
predictors <- str_extract_all(as.character(likely_voter_fit$formula), '(?<= )[a-zA-Z_]*(?=[)]| )')[[1]]
#In order to speed up computation of posterior matrix, I compressed the post-stratification table
#to contain unique combinations of predictor values, to be merged with full table later
POSTSTRAT_UNIQUE <- poststrat_df |> select(all_of(predictors)) |> unique()
vote_choice_posterior <- mrp_posterior(vote_choice_fit, POSTSTRAT_UNIQUE)[1:N_DRAWS, , ]
mrp_list <- polytomous_mrp(posterior = vote_choice_posterior,
poststrat_full = poststrat_df)
vote_choice_array <- mrp_list$mrp_array
vote_margin <- mrp_list$margin_table
vote_margin <- override_no_contest(vote_margin)
#Re-weight MRP estimates such that sum of vote shares across districts equal
#national vote share projected by Pew Research
mrp_list <- reweight_mrp(vote_choice_array, vote_margin)
vote_array_weighted <- mrp_list$mrp_array
vote_margin_weighted <- mrp_list$margin_table
vote_margin_weighted <- override_no_contest(vote_margin_weighted)
write.csv(vote_margin, 'cleaned_data/mrp_margin.csv')
write.csv(vote_margin_weighted, 'cleaned_data/mrp_margin_weight.csv')
########################################################
#(3) District vote share estimates (weighted by turnout)
#element-wise posterior matrix multiplication of 2D matrix by each level of 3D matrix
adj_vote_choice_posterior <- sweep(vote_choice_posterior, c(1, 2), likely_voter_posterior, `*`)
mrp_list <- polytomous_mrp(posterior = adj_vote_choice_posterior,
poststrat_full = poststrat_df)
adj_vote_choice_array <- mrp_list$mrp_array
adj_vote_margin <- mrp_list$margin_table
adj_vote_margin <- override_no_contest(adj_vote_margin)
#Re-weight MRP estimates such that sum of vote shares across districts equal
#national vote share projected by Pew Research
mrp_list <- reweight_mrp(adj_vote_choice_array, adj_vote_margin)
adj_vote_array_weighted <- mrp_list$mrp_array
adj_vote_margin_weighted <- mrp_list$margin_table
adj_vote_margin_weighted <- override_no_contest(adj_vote_margin_weighted)
write.csv(adj_vote_margin, 'cleaned_data/mrp_margin_turnout.csv')
write.csv(adj_vote_margin_weighted, 'cleaned_data/mrp_margin_turnout_weight.csv')
library(tidyverse)
library(ggplot2)
library(stringr)
library(xtable)
library(patchwork)
library(stargazer)
setwd('~/DropBox/house_model/')
ENSEMBLE_WT_MRP <- 0.33
ENSEMBLE_WT_BASELINE <- 0.67
#Read MIT Data Lab congressional election returns for 2018 to assess models
house <- read.csv('cleaned_data/1976-2024-house.tab') |>
select(-state) |>
rename('state' = 'state_po') |>
#filter(year == 2018) |>
mutate(district = as.integer(district)) |>
filter(party == 'DEMOCRAT' | party == 'REPUBLICAN') |>
mutate(rvote = case_when(
party == 'REPUBLICAN' ~ candidatevotes,
.default = 0
),
dvote = case_when(
party == 'DEMOCRAT' ~ candidatevotes,
.default = 0
)) |>
group_by(district, state, year) |>
summarize(dvoteshr = sum(dvote)/sum(dvote + rvote),
rvoteshr = sum(rvote)/sum(dvote + rvote)) |>
mutate(
r_d_victory_margin_mit = rvoteshr - dvoteshr
)
baseline_pred <- read.csv('cleaned_data/baseline_mod_predictions.csv') |>
mutate(r_d_victory_margin_baseline = r_d_victory_margin_pred/100)
#Check that mit victory margins agree with DDHQ's
# x <- left_join(baseline_pred, house, by = c('state','year', 'district')) |>
#   select(r_d_victory_margin, r_d_victory_margin_mit, state, year, district)
# plot(x$r_d_victory_margin, x$r_d_victory_margin_mit)
mrp <- read.csv('cleaned_data/mrp_margin_turnout_weight.csv') |>
mutate(r_d_victory_margin_mrp = mean) |>
mutate(district = case_when(
state %in% c('AK', 'DE', 'MT', 'ND', 'SD', 'VT', 'WY') ~ 0,
.default = district
))
combined <- baseline_pred |>
mutate(r_d_victory_margin = case_when(
year == 2018 ~ NA,
.default = r_d_victory_margin
)) |>
left_join(mrp |> select(state, district, year, r_d_victory_margin_mrp, matches('[^q][0-9]+')),
by = c('state', 'district', 'year')) |>
left_join(house |> select(state, district, year, r_d_victory_margin_mit),
by = c('state', 'district', 'year')) |>
mutate(r_d_victory_margin = case_when(
year == 2018 ~ r_d_victory_margin_mit,
.default = r_d_victory_margin
)) |>
mutate(r_d_victory_margin_ensemble =
as.double(r_d_victory_margin_mrp)*ENSEMBLE_WT_MRP +
as.double(r_d_victory_margin_baseline)*ENSEMBLE_WT_BASELINE) |>
select(state, district, year,
r_d_victory_margin,
r_d_victory_margin_baseline,
r_d_victory_margin_mrp,
r_d_victory_margin_ensemble,
matches('[0-9]+')
) |>
filter(year == 2018)
################################################################################
#Figure: Visualize correlation between 3 models' estimates and outcome
get_model_names <- function(vec){
result <- case_when(
vec == 'r_d_victory_margin_mrp' ~ 'MRP',
vec == 'r_d_victory_margin_baseline' ~ 'Baseline',
vec =='r_d_victory_margin_ensemble' ~ 'Ensemble'
)
return (result)
}
cor_mrp <- cor(combined$r_d_victory_margin, combined$r_d_victory_margin_mrp, use = 'complete.obs')
cor_baseline <- cor(combined$r_d_victory_margin, combined$r_d_victory_margin_baseline, use = 'complete.obs')
cor_ensemble <- cor(combined$r_d_victory_margin, combined$r_d_victory_margin_ensemble, use = 'complete.obs')
cat(paste0('Corr of mrp model predictions and vote share: ', format(cor_mrp, digits = 4)))
cat(paste0('Corr of baseline model predictions and vote share: ', format(cor_baseline, digits = 4)))
cat(paste0('Corr of ensemble model predictions and vote share: ', format(cor_ensemble, digits = 4)))
cor_data <- data.frame(correlation = c(cor_mrp, cor_baseline, cor_ensemble),
model = c('r_d_victory_margin_mrp',
'r_d_victory_margin_baseline',
'r_d_victory_margin_ensemble'))
plot_data <- pivot_longer(combined, cols = c('r_d_victory_margin_baseline',
'r_d_victory_margin_mrp',
'r_d_victory_margin_ensemble',
),
names_to = 'model',
values_to = 'estimate') |>
mutate(area = paste0(state, '-', district)) |>
left_join(cor_data, by = 'model') |>
select(-matches('X', ignore.case = F)) |>
dplyr::rename(
`Estimated Victory Margin` = estimate,
`Actual Victory Margin` = r_d_victory_margin
) |>
mutate(correlation_str = sprintf(
"R = %1.5s",
correlation)) |>
mutate(model_str = get_model_names(model))
cor_labels <- cor_data |>
mutate(correlation_str = sprintf("R = %.3f", correlation)) |>
mutate(model_str = get_model_names(model))
ggplot(
plot_data,
aes(x = `Estimated Victory Margin`, y = `Actual Victory Margin` )) +
geom_smooth(method = "lm", se = TRUE, color = "blue") +
facet_wrap(~ model_str, nrow = 3) +
geom_point(
size = 0.2,
alpha = 0.2
) +
geom_text(
size = 2,
label = plot_data$area,
nudge_x = 0, nudge_y = 0,
check_overlap = T ) +
geom_text(
data = cor_labels,
aes(x = 1, y = -0.8, label = correlation_str),
inherit.aes = FALSE,
hjust = 1.05,
vjust = 1.5,
size = 5) +
labs(
title = "Estimated versus Actual Victory Margins",
x = "Estimated Victory Margin (R - D)", y = "Actual Victory Margin (R - D)") +
theme_bw() +
theme( plot.title = element_text(size = 14, hjust = 0.5))
###Save to file
outfile <- paste0('figures/model_corr.png')
ggsave(outfile, height = 7, width = 7)
###Compute nr misses, nr gop seats, and rmse
miss_mrp <- sum(ifelse( (combined$r_d_victory_margin > 0 & combined$r_d_victory_margin_mrp <= 0) |
(combined$r_d_victory_margin <= 0 & combined$r_d_victory_margin_mrp > 0),
1, 0 ), na.rm = T)
miss_baseline <- sum(ifelse( (combined$r_d_victory_margin > 0 & combined$r_d_victory_margin_baseline <= 0) |
(combined$r_d_victory_margin <= 0 & combined$r_d_victory_margin_baseline > 0),
1, 0), na.rm = T)
miss_ensemble <- sum(ifelse( (combined$r_d_victory_margin > 0 & combined$r_d_victory_margin_ensemble <= 0) |
(combined$r_d_victory_margin <= 0 & combined$r_d_victory_margin_ensemble > 0),
1, 0), na.rm = T)
cat(paste0('Mrp model predictions missed races: ', format(miss_mrp, digits = 4)))
cat(paste0('Baseline model predictions missed races: ', format(miss_baseline, digits = 4)))
cat(paste0('Ensemble model predictions missed races: ', format(miss_ensemble, digits = 4)))
diff_mrp <- sum(ifelse( (combined$r_d_victory_margin_mrp >= 0), 1, 0 ), na.rm = T)
diff_baseline <- sum(ifelse( (combined$r_d_victory_margin_baseline >= 0), 1, 0 ), na.rm = T)
diff_ensemble <- sum(ifelse( (combined$r_d_victory_margin_ensemble >= 0), 1, 0 ), na.rm = T)
cat(paste0('Mrp model predicted GOP seats: ', format(diff_mrp, digits = 4)))
cat(paste0('Baseline model predicted GOP seats: ', format(diff_baseline, digits = 4)))
cat(paste0('Ensemble model predicted GOP seats: ', format(diff_ensemble, digits = 4)))
rmse_mrp <- mean((combined$r_d_victory_margin - combined$r_d_victory_margin_mrp)^2, na.rm = T)^0.5
rmse_baseline <- mean((combined$r_d_victory_margin - combined$r_d_victory_margin_baseline)^2, na.rm = T)^0.5
rmse_ensemble <- mean((combined$r_d_victory_margin - combined$r_d_victory_margin_ensemble)^2, na.rm = T)^0.5
cat(paste0('Mrp model predictions RMSE: ', format(rmse_mrp, digits = 4)))
cat(paste0('Baseline model predictions RMSE: ', format(rmse_baseline, digits = 4)))
cat(paste0('Ensemble model predictions RMSE: ', format(rmse_ensemble, digits = 4)))
################################################################################
#Table: performance statistics for 3 models
results_tbl <- data.frame(model = c('MRP','Baseline','Ensemble'),
R = c(cor_mrp, cor_baseline, cor_ensemble),
Missed_Races = c(miss_mrp, miss_baseline, miss_ensemble),
Predicted_GOP_Seats = c(diff_mrp, diff_baseline, diff_ensemble),
RMSE = c(rmse_mrp, rmse_baseline, rmse_ensemble)
) |> t()
latex_tbl <- xtable(results_tbl,
caption = "Model Performance on 2018 U.S. House Elections",
label = "tab:model_performance_2018",
align = c("l", "l", "c", "c") )
print(latex_tbl,
file = "tables/model_performance_2018.tex",
include.rownames = FALSE,
caption.placement = "top")
################################################################################
#Table: Baseline regression coefficients
baseline_mod <- readRDS('models/baseline_model.rds')
stargazer(baseline_mod, out = 'tables/baseline_model.tex')
################################################################################
#Create posterior distribution plot of ensemble and mrp models
posterior_ensemble <- combined |>
select(state, district, year, r_d_victory_margin_baseline, matches('X', ignore.case = F)) |>
mutate(across(matches('X', ignore.case = F),
~ . * ENSEMBLE_WT_MRP + r_d_victory_margin_baseline * ENSEMBLE_WT_BASELINE))
seats_ensemble <- data.frame(seats_ensemble = apply(posterior_ensemble |> select(matches('X', ignore.case = F)),
MARGIN = 2, function(x) {sum(ifelse(x > 0, 1, 0))}) |>
as.vector())
seats_mrp <- data.frame(seats_mrp = apply(combined |> select(matches('X', ignore.case = F)),
MARGIN = 2, function(x) {sum(ifelse(x > 0, 1, 0))}) |>
as.vector())
data_post <- data.frame(seats_ensemble, seats_mrp) |>
pivot_longer(everything(), names_to = 'Model', values_to= 'Estimate') |>
mutate(model_str = case_when(
Model == 'seats_ensemble' ~ 'Ensemble',
Model == 'seats_mrp' ~ 'MRP'
))
plt_mrp <- ggplot(data = seats_mrp, aes(seats_mrp)) +
geom_histogram(
fill = "#1f78b4",
color = "black",
binwidth = 3) +
labs(x = 'Projected GOP House Seats\n (1000 Draws)', y = 'Frequency', title = 'MRP Model') +
theme_bw() +
theme(plot.title = element_text(size = 14, hjust = 0.5),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10)) +
scale_x_continuous(labels =c(140,150,160,170),
breaks =c(140,150,160,170) )
plt_ensemble <- ggplot(data = seats_ensemble, aes(seats_ensemble)) +
geom_histogram(
binwidth = 1,
fill = "#1f78b4",
color = "black") +
labs(x = 'Projected GOP House Seats\n (1000 Draws)', y = 'Frequency', title = 'Ensemble Model') +
theme_bw() +
theme(plot.title = element_text(size = 14, hjust = 0.5),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10)) +
scale_x_continuous(labels =c(188, 191, 194, 197, 200),
breaks  =c(188, 191, 194, 197, 200))
###Save to file
outfile <- paste0('figures/posterior_draws.png')
ggsave(outfile, plt_mrp | plt_ensemble, height = 7/2, width = 7)
################################################################################
##Add ensemble results to ddhq data as final prediction
final_prediction <- read.csv('cleaned_data/ddhq_data.csv') |>
mutate(R.D.Victory.Margin = case_when(
R.D.Victory.Margin == '???' ~ NA_character_,
.default = R.D.Victory.Margin
)) |>
mutate(R.D.Victory.Margin = as.double(R.D.Victory.Margin)) |>
left_join(combined |>
select(state, year, district, r_d_victory_margin_ensemble) |>
rename('State' = 'state',
'Year' = 'year',
'Congressional.District' = 'district'),
by = c('State', 'Year', 'Congressional.District')) |>
mutate(R.D.Victory.Margin = coalesce(R.D.Victory.Margin, r_d_victory_margin_ensemble*100))
write.csv(final_prediction, 'cleaned_data/FINAL_PREDICTION.csv')
